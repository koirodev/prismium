document.addEventListener('DOMContentLoaded', () => {
    const contentElement = document.getElementById('content');

    // Создадим псевдо-объект instance с опциями для кастомного эффекта
    const instance = {
        // Опции, передаваемые в кастомный эффект
        options: {
            effectCustom: {
                speed: 300, // продолжительность анимации в мс
                delay: 100, // задержка между анимациями элементов
                setup: (child: HTMLElement, index: number, total: number, isOpening: boolean) => {
                    // Начальная настройка: например, скрыть элемент
                    child.style.opacity = '0';
                    console.log(`Setup ${index + 1}/${total} перед ${isOpening ? 'открытием' : 'закрытием'}`);
                },
                open: (child: HTMLElement, index: number, total: number) => {
                    // Анимация открытия: плавное появление
                    child.style.transition = 'opacity 0.3s';
                    child.style.opacity = '1';
                    console.log(`Элемент ${index + 1}/${total} открывается`);
                },
                close: (child: HTMLElement, index: number, total: number) => {
                    // Анимация закрытия: плавное исчезновение
                    child.style.transition = 'opacity 0.3s';
                    child.style.opacity = '0';
                    console.log(`Элемент ${index + 1}/${total} закрывается`);
                },
                cleanup: (child: HTMLElement, index: number, total: number, isOpening: boolean) => {
                    // Очистка: удаление временных стилей
                    child.style.transition = '';
                    console.log(`Очистка ${index + 1}/${total} после ${isOpening ? 'открытия' : 'закрытия'}`);
                },
            }
        },
        // Элемент, к которому прикрепляются дочерние элементы
        $content: contentElement!,
        // Простой менеджер таймеров, использующий глобальные функции
        timerManager: {
            setTimeout,
            clearTimeout
        }
    };

    // Допустим, контейнер содержит несколько <div> для применения эффекта.
    // Пример разметки HTML:
    // <div id="content">
    //   <div>Первый элемент</div>
    //   <div>Второй элемент</div>
    //   <div>Третий элемент</div>
    // </div>
    // Пусть метод #getFilteredChildren ищет дочерние элементы внутри $content

    // Создаём экземпляр EffectsManager
    const effectsManager = new EffectsManager();

    // Допустим, EffectsManager имеет публичный метод applyEffect, который внутри вызывает #applyCustomEffect.
    // Передаём instance и флаг (true - для открытия, false - для закрытия)
    effectsManager.applyEffect(instance, true);
});
